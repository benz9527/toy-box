package bit

// https://www.lintcode.com/problem/365/?fromId=6&_from=collection

// 分组统计，SWAR 算法

func CountOnes(n int) int {
	// 0x55555555 = 01010101010101010101010101010101
	// 保留原数字的奇数位的 1 + 保留原数字的偶数位的 1
	// 每两个二进制位表示原数字对应的二进制位的1的数量
	n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
	// 0x33333333 = 00110011001100110011001100110011
	// 保留上一步求出的和的右边两个位 + 保留上一步求出的和的左边两个位
	// 每四个二进制位表示原数字对应二进制位的 1 的数量
	n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
	// 0x0f0f0f0f = 00001111000011110000111100001111
	// 保留上一步求出的右边四个位 + 保留上一步求出的和的左边四个位
	// 每八个二进制位表示原数字对应二进制位的1的数量
	n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)
	// 0x00ff00ff = 00000000111111110000000011111111
	// 保留上一步求出的右边八个位 + 保留上一步求出的和的左边八个位
	// 每十六个二进制位表示原数字对应二进制位的1的数量
	n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff)
	// 0x0000ffff = 00000000000000001111111111111111
	// 保留上一步求出的右边十六个位 + 保留上一步求出的和的左边十六个位
	// 每三十二个二进制位表示原数字对应二进制位的1的数量
	n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff)
	return n
}

// CountOnes2 Example:
// 7 = (0111)2
// step 1:
// 0x7 & 0x55555555 = 0x5
// 0x7 >> 1 = 0x3, 0x3 & 0x55555555 = 0x1
// 0x5 + 0x1 = 0x6
// step 2:
// 0x6 & 0x33333333 = 0x2
// 0x6 >> 2 = 0x1, 0x1 & 0x33333333 = 0x1
// 0x2 + 0x1 = 0x3
// step 3:
// 0x3 & 0x0f0f0f0f = 0x3
// 0x3 >> 4 = 0x0, 0x0 & 0x0f0f0f0f = 0x0
// 0x3 + 0x0 = 0x3
// step 4:
// 0x3 * 0x01010101 = 0x03030303
// 0x03030303 & 0x3fffffff = 0x03030303
// 0x03030303 >> 24 = 0x3
func CountOnes2(n int) int {
	// 0x55555555 = 01010101010101010101010101010101
	// 保留原数字的奇数位的 1 + 保留原数字的偶数位的 1
	// 每两个二进制位表示原数字对应的二进制位的1的数量
	n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
	// 0x33333333 = 00110011001100110011001100110011
	// 保留上一步求出的和的右边两个位 + 保留上一步求出的和的左边两个位
	// 每四个二进制位表示原数字对应二进制位的 1 的数量
	n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
	// 0x0f0f0f0f = 00001111000011110000111100001111
	// 保留上一步求出的右边四个位 + 保留上一步求出的和的左边四个位
	// 每八个二进制位表示原数字对应二进制位的1的数量
	n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)
	// Hanmming Weight
	n = ((n * 0x01010101) & ((1 << 32) - 1)) >> 24
	return n
}

func CountOnes3(n int) int {
	count := make([]int, 16)
	count[0] = 0
	count[1] = 1
	count[2] = 1
	count[3] = 2
	count[4] = 1
	count[5] = 2
	count[6] = 2
	count[7] = 3
	count[8] = 1
	count[9] = 2
	count[10] = 2
	count[11] = 3
	count[12] = 2
	count[13] = 3
	count[14] = 3
	count[15] = 4

	res := 0
	for i := 0; i < 8; i++ {
		res += count[(n>>(i*4))&0xf]
	}
	return res
}
